[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Zoomalong",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "Journal/index.html#posts",
    "href": "Journal/index.html#posts",
    "title": "Blog",
    "section": "Posts",
    "text": "Posts\n\n\n    \n    \n                  \n            \n        \n        \n            \n\n            \n\n            \n            \n        \n        \n    \n    \n    \n                  \n            October 15, 2018\n        \n        \n            ARM Template Parameter/Variable Setup\n\n            \n            \n                \n                \n                    Azure\n                \n                \n                \n                    Arm Templates\n                \n                \n            \n            \n\n            \n            \n        \n        \n    \n    \n    \n                  \n            October 15, 2018\n        \n        \n            Azure Function Managed Service Identities\n\n            \n            \n                \n                \n                    Azure\n                \n                \n                \n                    Security\n                \n                \n                \n                    Managed Service Identities\n                \n                \n            \n            \n\n            Azure Function Managed Service Identities\n            \n        \n        \n    \n    \n    \n                  \n            October 10, 2018\n        \n        \n            ARM TEMPLATE PARAMETER/VARIABLE SETUP\n\n            \n            \n                \n                \n                    Azure\n                \n                \n                \n                    Arm Templates\n                \n                \n            \n            \n\n            \n            \n        \n        \n    \n    \n    \n                  \n            August 14, 2018\n        \n        \n            Azure Application Hosting\n\n            \n            \n                \n                \n                    Azure\n                \n                \n                \n                    Hosting\n                \n                \n            \n            \n\n            \n            \n        \n        \n    \n    \n    \n                  \n            August 14, 2018\n        \n        \n            Hosting Azure Static Websites\n\n            \n            \n                \n                \n                    Azure\n                \n                \n                \n                    Hosting\n                \n                \n                \n                    Static Websites\n                \n                \n            \n            \n\n            \n            \n        \n        \n    \n    \n    \n                  \n            August 14, 2018\n        \n        \n            Azure Application Hosting\n\n            \n            \n                \n                \n                    Azure\n                \n                \n                \n                    Hosting\n                \n                \n            \n            \n\n            \n            \n        \n        \n    \n    \n\nNo matching items"
  },
  {
    "objectID": "Journal/2018-10-15-ARMTemplateParameter-VariableSetup.html",
    "href": "Journal/2018-10-15-ARMTemplateParameter-VariableSetup.html",
    "title": "ARM Template Parameter/Variable Setup",
    "section": "",
    "text": "For something so simple, arm templates can become complex things, so I prefer to try to set some ground rules before I go to deep. N.B this works for me, and may not suit everyone ðŸ˜‰"
  },
  {
    "objectID": "Journal/2018-10-15-ARMTemplateParameter-VariableSetup.html#parameters",
    "href": "Journal/2018-10-15-ARMTemplateParameter-VariableSetup.html#parameters",
    "title": "ARM Template Parameter/Variable Setup",
    "section": "Parameters",
    "text": "Parameters\nI prefer to inject any unique values via a VSTS/VSO or if your prefer Azure DevOps deployment process.\nIn the first part of the file I spell out the acronyms which form part of the naming convention for the resources, you could use nested templates for this, but I feel they add unnecessary complications, as the nested template must be available via a URL. The second part involves parameters that are specific to this application, such as the tenant id, application name etc.\n{\n    \"$schema\": \"https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#\",\n    \"contentVersion\": \"1.0.0.0\",\n    \"parameters\": {\n        \"para_acronym_region\": { \"value\": \"we\" },\n        \"para_acronym_resgrp\": { \"value\": \"resgrp\" },\n        \"para_acronym_appsvc\": { \"value\": \"appsvc\" },\n        \"para_acronym_svcpln\": { \"value\": \"svcpln\" },\n        \"para_acronym_stract\": { \"value\": \"str\" },\n        \"para_acronym_kv\": { \"value\": \"kv\" },\n        \"para_acronym_azfunc\": { \"value\": \"fn\" },\n        \"para_acronym_appin\": { \"value\": \"appins\" },\n        \"para_acronym_webapp\": { \"value\": \"webapp\" },\n        \"para_ad_tenantid\": { \"value\": \" OVERWRITTEN BY VSTS \" },\n        \"para_application_name\": { \"value\": \" OVERWRITTEN BY VSTS \" },\n        \"para_vanity_name\": { \"value\": \" OVERWRITTEN BY VSTS \" },\n        \"para_target_env\": { \"value\": \"dev\" },\n        \"para_kvSecretsObject\": {\n            \"value\": {\n                \"secrets\": [\n                        {\n                        \"secretName\": \"applicationuser\",\n                        \"secretValue\": \"OVERWRITTEN BY VSTS\"\n                        },\n                        {\n                            \"secretName\": \"AnotherSecrect\",\n                            \"secretValue\": \"OVERWRITTEN BY VSTS\"\n                        }\n                    ]\n                }\n            }\n        }\n    }\n}"
  },
  {
    "objectID": "Journal/2018-10-15-ARMTemplateParameter-VariableSetup.html#variables",
    "href": "Journal/2018-10-15-ARMTemplateParameter-VariableSetup.html#variables",
    "title": "ARM Template Parameter/Variable Setup",
    "section": "Variables",
    "text": "Variables\nAs you can see from the variables, I build up my resource names from the parameters. I also pull in values for the hostingplan and component identities, so they can be used easily with the resource definitions.\n\"variables\": {\n    \"var_env_region\": \"[concat(parameters('para_target_env'), '-', parameters('para_acronym_region'))]\",\n    \"var_public_url\": \"[concat(parameters('para_target_env'), '.', parameters('para_application_name'), '.', parameters('para_vanity_name'))]\",\n    \"var_str_name\": \"[concat(parameters('para_application_name'), parameters('para_acronym_stract'), parameters('para_target_env'), parameters('para_acronym_region'))]\",\n    \"var_str_resId\": \"[resourceId(resourceGroup().Name,'Microsoft.Storage/storageAccounts', variables('var_str_name'))]\",\n    \"var_kv_name\": \"[concat(parameters('para_application_name'), '-', parameters('para_acronym_kv'), '-', variables('var_env_region'))]\",\n    \"var_azf_name\": \"[concat(parameters('para_application_name'), '-', parameters('para_acronym_azfunc'),'-', variables('var_env_region'))]\",\n    \"var_appin_name\": \"[concat(parameters('para_application_name'), '-', parameters('para_acronym_appin'),'-', variables('var_env_region'))]\",\n    \"var_hstpln_group\": \"[concat(parameters('para_application_name'), '-', parameters('para_acronym_resgrp'), '-', variables('var_env_region'))]\",\n    \"var_hstpln_env\": \"[concat(parameters('para_application_name'), '-', parameters('para_acronym_appsvc'), '-', variables('var_env_region'))]\",\n    \"var_hstpln_name\": \"[concat(parameters('para_application_name'), '-', parameters('para_acronym_svcpln'), '-', variables('var_env_region'))]\",\n    \"var_webapp_name\": \"[concat(parameters('para_application_name'), '-' ,parameters('para_acronym_webapp'),'-', variables('var_env_region'))]\",\n    \"var_webapp_hstpln\": \"[concat('/subscriptions/', subscription().subscriptionId, '/resourceGroups/', variables('var_hstpln_group'), '/providers/Microsoft.Web/serverfarms/', variables('var_hstpln_name'))]\",\n    \"var_msi_azf\": \"[concat(resourceId('Microsoft.Web/sites', variables('var_azf_name')),'/providers/Microsoft.ManagedIdentity/Identities/default')]\"\n},"
  },
  {
    "objectID": "Journal/2018-08-14-Hosting AzureStaticWebsites.html",
    "href": "Journal/2018-08-14-Hosting AzureStaticWebsites.html",
    "title": "Hosting Azure Static Websites",
    "section": "",
    "text": "Microsoft announced that you can now enable static websites on a storage account. This will generate a new URL for your site, and enable read access to any static html files within the blob storage. Thereâ€™s a link to Microsoftâ€™s preview announcement here. https://azure.microsoft.com/en-us/blog/azure-storage-static-web-hosting-public-preview/\nAt the moment I prefer the approach made by Anthony Chu in his blog post https://anthonychu.ca/post/azure-functions-static-file-server/\nHe hosts a index.html file within a Azure function Http Trigger request. Although this only returns a static file, it does allow you to create a on demand website. The Html file you serve up can should only contain links to CDN resources or to readable JS or other files within your storage account blob storage. By proxying the azure function then everything could be accessed via the same URL.\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.WebJobs;\nusing Microsoft.Azure.WebJobs.Extensions.Http;\nusing Microsoft.Azure.WebJobs.Host;\nusing MimeTypes;\n\nnamespace Counterflip\n{\n    public static class WebSite\n    {\n        [FunctionName(\"WebSite\")]\n        public static async Task&lt;HttpResponseMessage&gt; Run([HttpTrigger(AuthorizationLevel.Anonymous, \"get\", \"post\", Route = null)]HttpRequestMessage req, TraceWriter log)\n        {\n            log.Info(\"C# HTTP trigger function processed a request.\");\n\n            try\n            {\n                var response = new HttpResponseMessage(HttpStatusCode.OK);\n                var stream = new FileStream(@\"www\\index.html\", FileMode.Open);\n                response.Content = new StreamContent(stream);\n                response.Content.Headers.ContentType =\n                    new MediaTypeHeaderValue(GetMimeType(@\"www\\index.html\"));\n                return response;\n            }\n            catch\n            {\n                return new HttpResponseMessage(HttpStatusCode.NotFound);\n            }\n        }\n\n        private static string GetMimeType(string filePath)\n        {\n            var fileInfo = new FileInfo(filePath);\n            return MimeTypeMap.GetMimeType(fileInfo.Extension);\n        }\n    }\n}"
  },
  {
    "objectID": "Journal/2018-08-14-AzureApplicationHosting.html",
    "href": "Journal/2018-08-14-AzureApplicationHosting.html",
    "title": "Azure Application Hosting",
    "section": "",
    "text": "Each component is a separately deploy-able artefact, but we need a coherent single URL to link them all. The normal method would be to deploy out each individual component to Azure and each would get its own â€˜aurewebsites.comâ€™ URL. This approach would lead to confusion, as it would mean you would need to keep lists of URLâ€™s By using the proxy feature of Azure Functions we can define routes to each of the installed artefacts while preserving a single URL for the application. So:-\n\n\n\nRoute\nResult\n\n\n\n\nzoomalong.co.uk\nWebsite\n\n\nzoomalong.co.uk/api\nAzure functions\n\n\nzoomalong.co.uk/static\nAzure Storage Account\n\n\n\nUsed to store any files or images etc. Because both the API and Web Application exist on the same URL then we wonâ€™t run into any CORS issues. Remember to bind the DNS Cname to the Azure function proxy and not the website.\n\n\n\naah1\n\n\nHow ? In your Azure Functions Project Create a files called proxies.json and insert the following code\nproxies.json\n{\n  \"$schema\": \"http://json.schemastore.org/proxies\",\n    \"proxies\": {\n      \"api\": {\n        \"matchCondition\": {\n          \"route\": \"/api/{*url}\"\n        },\n        \"backendUri\": \"Set With Build Variable/{url}\"\n      },\n      \"app\": {\n        \"matchCondition\": {\n          \"route\": \"{*url}\",\n          \"methods\": [ \"GET\", \"HEAD\", \"OPTIONS\" ]\n        },\n        \"backendUri\": \"Set With Build Variable/{url}\"\n      },\n      \"appResources\": {\n        \"matchCondition\": {\n          \"route\": \"/static/{*url}\",\n          \"methods\": [ \"GET\", \"HEAD\", \"OPTIONS\" ]\n        },\n        \"backendUri\": \"Set With Build Variable/{url}\"\n      }\n    }\n  }\nChange in the build. * Build should include Azure App Service Deploy V3 or greater * Update this section with the file to be changed. *  * Add your substitutions to the Variables section * As Path to variable to be replace element.element.element * Value to be replaced. * as below\n\n\n\n\n\n\n\nProxy\nURL\n\n\n\n\nproxies.api.backendUri\nhttps://azure website url\n\n\nproxies.app.backendUri\nhttps://azure function url\n\n\nproxies.appResources.backendUri\nhttps:// azure storage account blob strorage\n\n\n\n\nRepeat in the release."
  },
  {
    "objectID": "Journal/2018-10-10-Arm-Template-ParameterVariable-Setup.html",
    "href": "Journal/2018-10-10-Arm-Template-ParameterVariable-Setup.html",
    "title": "ARM TEMPLATE PARAMETER/VARIABLE SETUP",
    "section": "",
    "text": "For something so simple, arm templates can become complex things, so I prefer to try to set some ground rules before I go to deep.\nN.B this works for me, and may not suit everyone ðŸ˜‰\nYou should employee a naming convention for your artifacts. Every Resource should be tagged. There should be a clear naming convention between the parameters and variables. Parameters should be either primitives or unique values Variables should build up your resource names from the parameter primitives. ### Parameters I prefer to inject any unique values via a VSTS/VSO or if your prefer Azure DevOps deployment process.\nIn the first part of the file I spell out the acronyms which form part of the naming convention for the resources, you could use nested templates for this, but I feel the add unnecessary complications, as the nested template must be available via a URL.\nThe second part involves parameters that are specific to this application, such as the tenant id, application name etc.\n{\n    \"$schema\": \"https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#\",\n    \"contentVersion\": \"1.0.0.0\",\n    \"parameters\": {\n        \"para_acronym_region\": { \"value\": \"we\" },\n        \"para_acronym_resgrp\": { \"value\": \"resgrp\" },\n        \"para_acronym_appsvc\": { \"value\": \"appsvc\" },\n        \"para_acronym_svcpln\": { \"value\": \"svcpln\" },\n        \"para_acronym_stract\": { \"value\": \"str\" },\n        \"para_acronym_kv\": { \"value\": \"kv\" },\n        \"para_acronym_azfunc\": { \"value\": \"fn\" },\n        \"para_acronym_appin\": { \"value\": \"appins\" },\n        \"para_acronym_webapp\": { \"value\": \"webapp\" },\n        \"para_ad_tenantid\": { \"value\": \" OVERWRITTEN BY VSTS \" },\n        \"para_application_name\": { \"value\": \" OVERWRITTEN BY VSTS \" },\n        \"para_vanity_name\": { \"value\": \" OVERWRITTEN BY VSTS \" },\n        \"para_target_env\": { \"value\": \"dev\" },\n        \"para_kvSecretsObject\": {\n            \"value\": {\n                \"secrets\": [\n                {\n                    \"secretName\": \"applicationuser\",\n                    \"secretValue\": \"OVERWRITTEN BY VSTS\"\n                },\n                {\n                    \"secretName\": \"AnotherSecrect\",\n                    \"secretValue\": \"OVERWRITTEN BY VSTS\"\n                }\n                ]\n            }\n        }\n    }\n}\n\nVariables\nAs you can see from the variables, I build up my resource names from the parameters.\nI also pull in values for the hostingplan and component identities, so they can be used easily with the resource definitions.\n\"variables\": {\n    \"var_env_region\": \"[concat(parameters('para_target_env'), '-', parameters('para_acronym_region'))]\",\n    \"var_public_url\": \"[concat(parameters('para_target_env'), '.', parameters('para_application_name'), '.', parameters('para_vanity_name'))]\",\n    \"var_str_name\": \"[concat(parameters('para_application_name'), parameters('para_acronym_stract'), parameters('para_target_env'), parameters('para_acronym_region'))]\",\n    \"var_str_resId\": \"[resourceId(resourceGroup().Name,'Microsoft.Storage/storageAccounts', variables('var_str_name'))]\",\n    \"var_kv_name\": \"[concat(parameters('para_application_name'), '-', parameters('para_acronym_kv'), '-', variables('var_env_region'))]\",\n    \"var_azf_name\": \"[concat(parameters('para_application_name'), '-', parameters('para_acronym_azfunc'),'-', variables('var_env_region'))]\",\n    \"var_appin_name\": \"[concat(parameters('para_application_name'), '-', parameters('para_acronym_appin'),'-', variables('var_env_region'))]\",\n    \"var_hstpln_group\": \"[concat(parameters('para_application_name'), '-', parameters('para_acronym_resgrp'), '-', variables('var_env_region'))]\",\n    \"var_hstpln_env\": \"[concat(parameters('para_application_name'), '-', parameters('para_acronym_appsvc'), '-', variables('var_env_region'))]\",\n    \"var_hstpln_name\": \"[concat(parameters('para_application_name'), '-', parameters('para_acronym_svcpln'), '-', variables('var_env_region'))]\",\n    \"var_webapp_name\": \"[concat(parameters('para_application_name'), '-' ,parameters('para_acronym_webapp'),'-', variables('var_env_region'))]\",\n    \"var_webapp_hstpln\": \"[concat('/subscriptions/', subscription().subscriptionId, '/resourceGroups/', variables('var_hstpln_group'), '/providers/Microsoft.Web/serverfarms/', variables('var_hstpln_name'))]\",\n    \"var_msi_azf\": \"[concat(resourceId('Microsoft.Web/sites', variables('var_azf_name')),'/providers/Microsoft.ManagedIdentity/Identities/default')]\"\n},"
  },
  {
    "objectID": "Journal/2018-10-15-AzureFunctionManagedServiceIdentities.html",
    "href": "Journal/2018-10-15-AzureFunctionManagedServiceIdentities.html",
    "title": "Azure Function Managed Service Identities",
    "section": "",
    "text": "Bootstrapping\nThe trouble with many security policies is that at least some element needs to know the password in order to instigate access to resources. That used to mean putting credentials into a configuration file or inserting them during a deployment process. The Manage Service Identities (MSI) facility has got around this by allowing all your resources to register a service principal with Active Directory, and then each resource grants the desired level of access to that service principal. By doing the security in this way, each of the resources never need to know credentials, they only request access and deal with the response. So, by removing credentials from the equation then there is no need to have to rotate passwords or update certs on a timely basis as they simply donï¿½t exist between the resources.\n\n\nSo how do we accomplish this.\nWithin the azure function arm template declaration insert the following, this will register the function with your active directory.\n\"identity\": {\"type\": \"SystemAssigned\"},\nIn the variables section of the Arm Template, get the identity of the Azure Function. (replace â€˜var_azf_nameâ€™ with the name of your function)\n\"var_msi_azf\": \"[concat(resourceId('Microsoft.Web/sites', variables('var_azf_name')),'/providers/Microsoft.ManagedIdentity/Identities/default')]\"\nWithin your Key Vault template your will need to add the functions access policy\n\"accessPolicies\": [{\"tenantId\": \"[reference(variables('var_msi_azf'), '2015-08-31-PREVIEW').tenantId]\",\"objectId\": \"[reference(variables('var_msi_azf'), '2015-08-31-PREVIEW').principalId]\",\"permissions\": {\"certificates\": [\"get\"],\"keys\": [\"get\"],\"secrets\": [\"get\"]}}}]"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "Journal/2018/08/2018-08-14-AzureApplicationHosting.html",
    "href": "Journal/2018/08/2018-08-14-AzureApplicationHosting.html",
    "title": "Azure Application Hosting",
    "section": "",
    "text": "Each component is a separately deploy-able artefact, but we need a coherent single URL to link them all. The normal method would be to deploy out each individual component to Azure and each would get its own â€˜aurewebsites.comâ€™ URL. This approach would lead to confusion, as it would mean you would need to keep lists of URLâ€™s By using the proxy feature of Azure Functions we can define routes to each of the installed artefacts while preserving a single URL for the application. So:-\n\n\n\nRoute\nResult\n\n\n\n\nzoomalong.co.uk\nWebsite\n\n\nzoomalong.co.uk/api\nAzure functions\n\n\nzoomalong.co.uk/static\nAzure Storage Account\n\n\n\nUsed to store any files or images etc. Because both the API and Web Application exist on the same URL then we wonâ€™t run into any CORS issues. Remember to bind the DNS Cname to the Azure function proxy and not the website.\n\n\n\naah1\n\n\nHow ? In your Azure Functions Project Create a files called proxies.json and insert the following code\nproxies.json\n{\n  \"$schema\": \"http://json.schemastore.org/proxies\",\n    \"proxies\": {\n      \"api\": {\n        \"matchCondition\": {\n          \"route\": \"/api/{*url}\"\n        },\n        \"backendUri\": \"Set With Build Variable/{url}\"\n      },\n      \"app\": {\n        \"matchCondition\": {\n          \"route\": \"{*url}\",\n          \"methods\": [ \"GET\", \"HEAD\", \"OPTIONS\" ]\n        },\n        \"backendUri\": \"Set With Build Variable/{url}\"\n      },\n      \"appResources\": {\n        \"matchCondition\": {\n          \"route\": \"/static/{*url}\",\n          \"methods\": [ \"GET\", \"HEAD\", \"OPTIONS\" ]\n        },\n        \"backendUri\": \"Set With Build Variable/{url}\"\n      }\n    }\n  }\nChange in the build. * Build should include Azure App Service Deploy V3 or greater * Update this section with the file to be changed. *  * Add your substitutions to the Variables section * As Path to variable to be replace element.element.element * Value to be replaced. * as below\n\n\n\n\n\n\n\nProxy\nURL\n\n\n\n\nproxies.api.backendUri\nhttps://azure website url\n\n\nproxies.app.backendUri\nhttps://azure function url\n\n\nproxies.appResources.backendUri\nhttps:// azure storage account blob strorage\n\n\n\n\nRepeat in the release."
  }
]